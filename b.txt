Perfect ‚Äî this JSON is clean and stable, so let‚Äôs model it **properly** in TypeScript instead of flattening it üëç
I‚Äôll give you a **faithful, strongly-typed interface hierarchy** that matches the JSON *exactly* and still works nicely in your ASPX interop world.

---

## 1Ô∏è‚É£ Full TypeScript model for your JSON

### `types/invoiceTypes.ts`

```ts
export interface ExtractedDocumentData {
  documentKey: string;
  documentType: "Invoice" | string;
  extractedAtUtc: string; // ISO timestamp
  provider: string;
  modelVersion: string;
  overallConfidence: number;

  invoice: ExtractedInvoice;

  vendorMatchType: VendorMatchType;
  vendorCandidates: VendorCandidate[];
}
```

---

## 2Ô∏è‚É£ Invoice object (nested)

```ts
export interface ExtractedInvoice {
  vendorText: string;
  invoiceDate: string; // YYYY-MM-DD
  dueDate: string;
  checkDate: string;
  totalAmount: number;
  summaryDescription: string;
}
```

---

## 3Ô∏è‚É£ Vendor match types (IMPORTANT)

This should **not** be a plain string anymore.

```ts
export type VendorMatchType =
  | "exact"
  | "multiple"
  | "no_match";
```

This immediately gives you:

* autocomplete
* compile-time safety
* cleaner switch logic

---

## 4Ô∏è‚É£ Vendor candidates

```ts
export interface VendorCandidate {
  vendorId: number;
  vendorKey: number;
  vendorName: string;

  // Optional ‚Äî future-proofing
  score?: number;
}
```

Your current JSON doesn‚Äôt include `score`, but your older logic did ‚Äî making it optional is the right move.

---

## 5Ô∏è‚É£ Update your fetch signature

### Before

```ts
async function fetchExtractedInvoice(
  documentKey: string
): Promise<ExtractedInvoiceData | null>
```

### After (correct)

```ts
async function fetchExtractedInvoice(
  documentKey: string
): Promise<ExtractedDocumentData | null> {
  try {
    const res = await fetch(`/api/documents/${documentKey}/extracted-data`);
    if (!res.ok) return null;

    return (await res.json()) as ExtractedDocumentData;
  } catch {
    return null;
  }
}
```

---

## 6Ô∏è‚É£ Minimal changes to existing code

### Applying invoice fields

```ts
function applyExtractedDataToAspx(data: ExtractedDocumentData): void {
  const invoice = data.invoice;

  setInputValue("MainContent_txtInvoiceDate", invoice.invoiceDate);
  setInputValue("MainContent_txtAmount", invoice.totalAmount.toString());

  setInputValue("MainContent_hdnVendorID", "");
  setInputValue("MainContent_hdnVendorKey", "");
  setInputValue(
    "MainContent_txtVendor",
    invoice.vendorText
  );
}
```

---

## 7Ô∏è‚É£ Vendor decision flow (clean & typed)

```ts
handleVendorSelection(
  data.vendorMatchType,
  data.vendorCandidates
);
```

And now `handleVendorSelection` can safely do:

```ts
switch (matchType) {
  case "exact":
    applyVendor(candidates[0]);
    break;

  case "multiple":
    showVendorDialog(candidates);
    break;

  case "no_match":
    showVendorNoMatchDialog();
    break;
}
```

No magic strings. No guessing.

---

## 8Ô∏è‚É£ Why this structure is the *right* one

‚úî Mirrors backend JSON 1:1
‚úî Avoids fragile flattened fields
‚úî Lets backend evolve without breaking UI
‚úî Makes vendor logic explicit and readable
‚úî Senior-level modeling (this matters in reviews)

---

## TL;DR

You should **replace** your old `ExtractedInvoiceData` with:

```ts
ExtractedDocumentData
 ‚îú‚îÄ‚îÄ invoice
 ‚îú‚îÄ‚îÄ vendorMatchType
 ‚îî‚îÄ‚îÄ vendorCandidates
```

This aligns:

* backend DTO
* frontend TS
* legacy ASPX expectations

If you want next, I can:

* add **runtime validation** (zod)
* show how to handle **future document types**
* or refactor vendor logic into a pure decision engine

You‚Äôre doing excellent work here ‚Äî this is *real* modernization, not lipstick üëè
