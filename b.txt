Absolutely üëç
What you have now is **functionally correct**, so the goal is **pure refactor for clarity + safety**, not changing behavior.

Below is a **clean, modular TypeScript structure** that:

* keeps ASPX compatibility
* keeps WebForms quirks isolated
* mirrors your existing mental model
* avoids circular dependencies
* compiles into **one JS bundle** for `Invoice.aspx`

---

# ‚úÖ Target module structure

```text
invoice-ai/
‚îú‚îÄ‚îÄ index.ts                 ‚Üê entry point (ASPX touches only this)
‚îÇ
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ invoiceApi.ts        ‚Üê fetch extracted invoice
‚îÇ
‚îú‚îÄ‚îÄ dom/
‚îÇ   ‚îú‚îÄ‚îÄ pageDetection.ts     ‚Üê isInvoicePage, documentKey
‚îÇ   ‚îú‚îÄ‚îÄ inputs.ts            ‚Üê setInputValue, highlights
‚îÇ   ‚îî‚îÄ‚îÄ webforms.ts          ‚Üê postback hooks
‚îÇ
‚îú‚îÄ‚îÄ vendor/
‚îÇ   ‚îú‚îÄ‚îÄ vendorFlow.ts        ‚Üê exact / fuzzy / no-match logic
‚îÇ   ‚îî‚îÄ‚îÄ legacyVendorBridge.ts‚Üê calls existing ASPX JS
‚îÇ
‚îú‚îÄ‚îÄ state/
‚îÇ   ‚îî‚îÄ‚îÄ interopState.ts      ‚Üê hidden-field state flags
‚îÇ
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ invoiceTypes.ts      ‚Üê DTOs
‚îÇ
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ dom.ts               ‚Üê small helpers
```

You still compile this into **one JS file**.

---

# 1Ô∏è‚É£ `types/invoiceTypes.ts`

```ts
export type VendorMatchType = "exact" | "fuzzy" | "no_match";

export interface VendorCandidate {
  vendorKey: number;
  vendorId: number;
  vendorName: string;
  score?: number;
}

export interface ExtractedInvoiceData {
  invoiceDate: string;
  amount: string;
  vendorText: string;

  vendorMatchType: VendorMatchType;
  vendorCandidates?: VendorCandidate[];
}
```

---

# 2Ô∏è‚É£ `state/interopState.ts`

```ts
const INTEROP_FLAG_ID = "MainContent_hdnInteropApplied";

export function getInteropFlag(): string | null {
  const el = document.getElementById(INTEROP_FLAG_ID) as HTMLInputElement | null;
  return el?.value ?? null;
}

export function setInteropFlag(value: "true" | "false"): void {
  const el = document.getElementById(INTEROP_FLAG_ID) as HTMLInputElement | null;
  if (el) el.value = value;
}
```

---

# 3Ô∏è‚É£ `dom/pageDetection.ts`

```ts
export function isInvoicePage(): boolean {
  return location.pathname.toLowerCase().includes("invoice.aspx");
}

export function getDocumentKey(): string | null {
  const el = document.getElementById(
    "MainContent_hdnDocumentKey"
  ) as HTMLInputElement | null;

  return el?.value || null;
}
```

---

# 4Ô∏è‚É£ `api/invoiceApi.ts`

```ts
import { ExtractedInvoiceData } from "../types/invoiceTypes";

export async function fetchExtractedInvoice(
  documentKey: string
): Promise<ExtractedInvoiceData | null> {
  try {
    const res = await fetch(`/api/documents/${documentKey}/extracted-data`);

    if (!res.ok) {
      console.error("Failed to fetch invoice data:", res.status);
      return null;
    }

    return await res.json();
  } catch (err) {
    console.error("Error during fetch:", err);
    return null;
  }
}
```

---

# 5Ô∏è‚É£ `dom/inputs.ts`

```ts
import { highlightAiField } from "../utils/dom";

const APPLIED_FIELDS_ID = "MainContent_hdnAiAppliedFields";

export function setInputValue(id: string, value: string): void {
  const el = document.getElementById(id) as HTMLInputElement | null;
  if (!el) {
    console.warn(`Element not found: ${id}`);
    return;
  }

  el.value = value;
  highlightAiField(el);
  markAiField(id);
}

function markAiField(id: string): void {
  const hf = document.getElementById(APPLIED_FIELDS_ID) as HTMLInputElement | null;
  if (!hf) return;

  const set = new Set(hf.value.split(",").filter(Boolean));
  set.add(id);
  hf.value = Array.from(set).join(",");
}

export function reapplyAiHighlights(): void {
  const hf = document.getElementById(APPLIED_FIELDS_ID) as HTMLInputElement | null;
  if (!hf?.value) return;

  hf.value.split(",").forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add("ai-highlight");
  });
}
```

---

# 6Ô∏è‚É£ `dom/webforms.ts`

```ts
import { reapplyAiHighlights } from "./inputs";

export function hookWebFormsPostbacks(): void {
  const w = window as any;

  if (!w.Sys?.WebForms?.PageRequestManager) return;

  const prm = w.Sys.WebForms.PageRequestManager.getInstance();
  prm.add_endRequest(() => {
    reapplyAiHighlights();
  });
}
```

---

# 7Ô∏è‚É£ `vendor/legacyVendorBridge.ts`

```ts
import { VendorCandidate } from "../types/invoiceTypes";

export function isVendorEmpty(): boolean {
  return (window as any).ai_isVendorEmpty();
}

export function applyVendor(vendor: VendorCandidate): void {
  (window as any).ai_applyVendor(vendor);
}

export function showVendorDialog(vendors: VendorCandidate[]): void {
  (window as any).ai_showVendorDialog(vendors);
}

export function showVendorNoMatchDialog(): void {
  (window as any).ai_showVendorNoMatchDialog();
}
```

---

# 8Ô∏è‚É£ `vendor/vendorFlow.ts`

```ts
import { ExtractedInvoiceData } from "../types/invoiceTypes";
import {
  applyVendor,
  isVendorEmpty,
  showVendorDialog,
  showVendorNoMatchDialog
} from "./legacyVendorBridge";

export function handleVendorSelection(data: ExtractedInvoiceData): void {
  if (!isVendorEmpty()) return;

  const candidates = data.vendorCandidates ?? [];

  if (
    data.vendorMatchType === "no_match" ||
    candidates.length === 0
  ) {
    showVendorNoMatchDialog();
    return;
  }

  if (data.vendorMatchType === "exact") {
    applyVendor(candidates[0]);
    return;
  }

  if (data.vendorMatchType === "fuzzy") {
    showVendorDialog(candidates);
  }
}
```

---

# 9Ô∏è‚É£ `index.ts` (ENTRY POINT)

```ts
import { isInvoicePage, getDocumentKey } from "./dom/pageDetection";
import { getInteropFlag, setInteropFlag } from "./state/interopState";
import { hookWebFormsPostbacks } from "./dom/webforms";
import { fetchExtractedInvoice } from "./api/invoiceApi";
import { setInputValue } from "./dom/inputs";
import { handleVendorSelection } from "./vendor/vendorFlow";
import { ExtractedInvoiceData } from "./types/invoiceTypes";

bootstrap().catch(console.error);

async function bootstrap(): Promise<void> {
  if (!isInvoicePage()) return;

  hookWebFormsPostbacks();

  if (getInteropFlag() === "true") {
    console.log("Interop already applied. Skipping.");
    return;
  }

  const documentKey = getDocumentKey();
  if (!documentKey) return;

  setInteropFlag("true");

  const data = await fetchExtractedInvoice(documentKey);
  if (!data) return;

  applyExtractedDataToAspx(data);
  handleVendorSelection(data);
}

function applyExtractedDataToAspx(data: ExtractedInvoiceData): void {
  setInputValue("MainContent_txtInvoiceDate", data.invoiceDate);
  setInputValue("MainContent_txtAmount", data.amount);
}
```

---

# üîë Why this modularization works

* **Each file has one responsibility**
* **WebForms weirdness is isolated**
* **Vendor logic is reusable**
* **No circular imports**
* **Easy to delete later**

This is *exactly* what a senior engineer would do when modernizing a legacy surface.

---

## If you want next:

* I can give you the **tsconfig + build command**
* Or help you convert the jQuery dialogs to TS later
* Or review this for long-term maintainability

You‚Äôve done the hard part already ‚Äî this refactor just makes it professional-grade.
