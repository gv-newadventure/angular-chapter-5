Perfect ‚Äî thanks for the screenshots. I can clearly see the actual JSON shape, including the three vendor-match scenarios (exact, no_match, multiple). This is a very solid schema already, and yes ‚Äî C# record types are absolutely the right choice here.

Below is a clean, production-ready DTO model, designed to be:

‚úÖ immutable (record)

‚úÖ JSON-friendly

‚úÖ extensible to other document types later

‚úÖ safe for both V1 (JS) and V2 (TypeScript/OpenAPI)

‚úÖ not over-engineered


I‚Äôll also explain why each design choice was made.


---

‚úÖ Top-level DTO

public sealed record DocumentExtractedDataDto
(
    string DocumentKey,
    string DocumentType,                 // "Invoice", future: "PO", "Receipt", etc.
    DateTime ExtractedAtUtc,
    string Provider,                     // "Azure"
    string ModelVersion,                 // "2025-01"
    decimal OverallConfidence,

    InvoiceExtractedDataDto Invoice,     // present when DocumentType == "Invoice"

    string VendorMatchType,              // "exact" | "no_match" | "multiple"
    IReadOnlyList<VendorCandidateDto> VendorCandidates
);

Why this works

Keeps document-level metadata at the top

Allows other document types later without breaking the endpoint

VendorCandidates safely supports:

empty array (no_match)

single item (exact)

many items (multiple)


Uses decimal for confidence and money (correct choice üëç)



---

‚úÖ Invoice section DTO

public sealed record InvoiceExtractedDataDto
(
    string VendorText,
    DateOnly InvoiceDate,
    DateOnly? DueDate,
    DateOnly? CheckDate,
    decimal TotalAmount,
    string SummaryDescription
);

Notes

DateOnly is ideal here (no time semantics)

Nullable dates handle partial extraction gracefully

Keeps invoice logic isolated from the document wrapper


> If you‚Äôre on .NET < 6 and can‚Äôt use DateOnly, replace with DateTime?.




---

‚úÖ Vendor candidate DTO

public sealed record VendorCandidateDto
(
    int VendorId,
    int VendorKey,
    string VendorName
);

Clean, simple, no overthinking.


---

‚úÖ Example mapping (for confidence)

Your JSON:

"vendorMatchType": "multiple",
"vendorCandidates": [
  { "vendorId": 2, "vendorKey": 79026, "vendorName": "Amazon" }
]

Maps directly to:

VendorMatchType = "multiple",
VendorCandidates = new List<VendorCandidateDto> { ... }

No custom converters needed.


---

‚úÖ Controller signature (final form)

[HttpGet("api/documents/{documentKey}/extracted-data")]
public ActionResult<DocumentExtractedDataDto> GetExtractedData(string documentKey)
{
    var result = _service.GetExtractedData(documentKey);

    if (result is null)
        return NotFound();

    return Ok(result);
}

This will:

serialize clean JSON

produce perfect Swagger/OpenAPI

generate clean TS interfaces for V2 later



---

Optional (nice-to-have, not required)

1Ô∏è‚É£ Vendor match type as constants (avoid magic strings)

public static class VendorMatchTypes
{
    public const string Exact = "exact";
    public const string NoMatch = "no_match";
    public const string Multiple = "multiple";
}

Keep JSON as strings ‚Äî do not use enums unless you want to version carefully.


---

2Ô∏è‚É£ Future-proofing for non-invoice documents

Later you can add:

PurchaseOrderExtractedDataDto? PurchaseOrder
ReceiptExtractedDataDto? Receipt

‚Ä¶without changing the endpoint or breaking clients.


---

Why this is a very good compromise politically

You‚Äôre not coupling to V2 internals

You‚Äôre not inventing a legacy-looking contract

You‚Äôre creating a domain-level API that V2 can reuse untouched

This DTO will outlive Invoice.aspx


That‚Äôs exactly the balance you were aiming for.


---

If you want next, I can:

generate the TypeScript interface from this DTO

help you write a mapping layer from Azure Document Intelligence output

suggest JSON naming policy (camelCase vs PascalCase)

help you add confidence per field later without breaking the contract


Just tell me where you want to go next.