In our architecture, the Private API and Public API are intentionally separated even though their controllers mirror the same routes and action methods. The Private API is the true execution layer of the system: it contains the real domain logic, interacts with the business layer, aggregators, and data access layer, and supports richer capabilities such as OData querying and internal error handling. It assumes a trusted caller and focuses purely on performing operations and returning results. The Public API, on the other hand, does not execute business logic directly. Instead, it acts as a controlled fa√ßade. Its responsibility is to authenticate the caller, build the appropriate authorization context (for example firm-level or scope-based access), enforce policy and access rules, and then delegate the request over HTTP to the Private API. The reason both APIs expose the same routes and actions is to keep the contract aligned while separating responsibilities: the Public API controls who can access functionality and under what constraints, while the Private API performs the actual work. This separation creates a clear trust boundary, prevents business logic from being directly exposed externally, and allows governance, auditing, throttling, and contract management to evolve independently from internal implementation details. In short, the Private API defines what the system does, and the Public API defines who can do it and under which rules, ensuring security, maintainability, and architectural clarity without duplicating business logic.