Perfect ‚Äî thanks for the full dump. This is enough context üëç
I‚Äôll focus on **unit tests that actually give you confidence**, not boilerplate.

I‚Äôll break this into **what to test**, then **concrete test methods** you can drop into `Remap.Tests`.

---

## 1Ô∏è‚É£ What should be unit-tested (and what shouldn‚Äôt)

### ‚úÖ Unit test (pure logic / orchestration)

1. **`PositionalXmlTransformer`**

   * MAP / DISCARD / APPEND behavior
   * Default values
   * Append unmapped fields logic
   * Error handling when XML is malformed

2. **`RemapOrchestrator.RunOneGlobalCycleAsync`**

   * No work claimed ‚Üí returns `false`
   * Work claimed but no documents ‚Üí returns `false`
   * Happy path ‚Üí applies batch and returns `true`
   * Transformer throws for one doc ‚Üí ERROR result still applied
   * Parallelism respected (indirectly)

### ‚ùå Do NOT unit test

* SQL repository (`SqlRemapRepository`) ‚Üí integration test
* Azure Function trigger (`RemapTimer`) ‚Üí thin wrapper

---

## 2Ô∏è‚É£ Test stack assumptions

I‚Äôll assume:

* **xUnit**
* **Moq**
* `.NET 6+`

```bash
dotnet add Remap.Tests package xunit
dotnet add Remap.Tests package Moq
dotnet add Remap.Tests package Microsoft.Extensions.Options
```

---

## 3Ô∏è‚É£ PositionalXmlTransformer tests (high value)

### ‚úÖ Test: MAP rule maps source ‚Üí target

```csharp
[Fact]
public void Transform_MapRule_MapsSourceFieldToTarget()
{
    var transformer = new PositionalXmlTransformer();

    var doc = new DocumentRecord(
        RemapId: 1,
        SiteCode: "US",
        DocumentKey: Guid.NewGuid(),
        Xml: "<FieldData><Field1>A</Field1></FieldData>",
        DocDesc: null,
        AppendUnmappedCategory: false
    );

    var rules = new List<RemapRuleDto>
    {
        new(1, targetFieldNumber: 2, action: "MAP", sourceFieldNumber: 1, defaultValue: null)
    };

    var result = transformer.Transform(
        doc,
        rules,
        appendUnmappedToDocDesc: false,
        sourceFieldLabels: null
    );

    Assert.Contains("<Field2>A</Field2>", result.NewXml);
    Assert.Equal("COMPLETED", result.Status);
}
```

---

### ‚úÖ Test: DISCARD clears target field

```csharp
[Fact]
public void Transform_DiscardRule_ClearsTargetField()
{
    var transformer = new PositionalXmlTransformer();

    var doc = new DocumentRecord(
        1, "US", Guid.NewGuid(),
        "<FieldData><Field1>A</Field1></FieldData>",
        null, false
    );

    var rules = new List<RemapRuleDto>
    {
        new(1, 1, "DISCARD", 1, null)
    };

    var result = transformer.Transform(doc, rules, false, null);

    Assert.Contains("<Field1 />", result.NewXml);
}
```

---

### ‚úÖ Test: Append unmapped fields with labels

```csharp
[Fact]
public void Transform_AppendsUnmappedFields_WithLabels()
{
    var transformer = new PositionalXmlTransformer();

    var doc = new DocumentRecord(
        1, "US", Guid.NewGuid(),
        "<FieldData><Field1>A</Field1><Field2>B</Field2></FieldData>",
        null,
        AppendUnmappedCategory: true
    );

    var rules = new List<RemapRuleDto>
    {
        new(1, 1, "MAP", 1, null)
    };

    var labels = new Dictionary<int, string>
    {
        { 2, "SecondField" }
    };

    var result = transformer.Transform(doc, rules, true, labels);

    Assert.Contains("SecondField: B", result.AppendNote);
}
```

---

## 4Ô∏è‚É£ RemapOrchestrator tests (core behavior)

### Test setup helper

```csharp
private static RemapOrchestrator CreateSut(
    Mock<IRemapRepository> repo,
    Mock<IRemapTransformer> transformer,
    RemapOptions options)
{
    return new RemapOrchestrator(
        repo.Object,
        transformer.Object,
        Options.Create(options),
        Mock.Of<ILogger<RemapOrchestrator>>()
    );
}
```

---

### ‚úÖ Test: No work claimed ‚Üí returns false

```csharp
[Fact]
public async Task RunOneGlobalCycle_NoWorkClaimed_ReturnsFalse()
{
    var repo = new Mock<IRemapRepository>();
    var transformer = new Mock<IRemapTransformer>();

    repo.Setup(r => r.ClaimNextGlobalBatchAsync(It.IsAny<int>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new ClaimedWorkItem(Array.Empty<ClaimedDoc>()));

    var sut = CreateSut(repo, transformer, new RemapOptions());

    var result = await sut.RunOneGlobalCycleAsync(CancellationToken.None);

    Assert.False(result);
}
```

---

### ‚úÖ Test: Happy path ‚Üí applies batch and returns true

```csharp
[Fact]
public async Task RunOneGlobalCycle_HappyPath_AppliesBatch()
{
    var repo = new Mock<IRemapRepository>();
    var transformer = new Mock<IRemapTransformer>();

    var claimedDoc = new ClaimedDoc(1, Guid.NewGuid(), "US", false);

    repo.Setup(r => r.ClaimNextGlobalBatchAsync(It.IsAny<int>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new ClaimedWorkItem(new[] { claimedDoc }));

    repo.Setup(r => r.GetRulesAsync(It.IsAny<IEnumerable<int>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<RemapRuleDto>());

    repo.Setup(r => r.GetSourceFieldsAsync(It.IsAny<IEnumerable<int>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<SourceFieldLabelDto>());

    repo.Setup(r => r.GetDocumentsAsync(It.IsAny<IEnumerable<ClaimedDoc>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<DocumentRecord>
        {
            new(1, "US", claimedDoc.DocumentKey, "<FieldData />", null, false)
        });

    transformer.Setup(t => t.Transform(
            It.IsAny<DocumentRecord>(),
            It.IsAny<IReadOnlyList<RemapRuleDto>>(),
            It.IsAny<bool>(),
            It.IsAny<IReadOnlyDictionary<int, string>>()))
        .Returns(new TransformedDoc("US", 1, claimedDoc.DocumentKey, "<FieldData />", null, "COMPLETED"));

    var sut = CreateSut(repo, transformer, new RemapOptions { Parallelism = 1 });

    var result = await sut.RunOneGlobalCycleAsync(CancellationToken.None);

    Assert.True(result);
    repo.Verify(r => r.ApplyBatchAsync(It.IsAny<IEnumerable<TransformedDoc>>(), It.IsAny<CancellationToken>()), Times.Once);
}
```

---

### ‚úÖ Test: Transformer throws ‚Üí ERROR doc still persisted

```csharp
[Fact]
public async Task RunOneGlobalCycle_TransformThrows_ProducesErrorResult()
{
    var repo = new Mock<IRemapRepository>();
    var transformer = new Mock<IRemapTransformer>();

    var docKey = Guid.NewGuid();

    repo.Setup(r => r.ClaimNextGlobalBatchAsync(It.IsAny<int>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new ClaimedWorkItem(new[] { new ClaimedDoc(1, docKey, "US", false) }));

    repo.Setup(r => r.GetRulesAsync(It.IsAny<IEnumerable<int>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<RemapRuleDto>());

    repo.Setup(r => r.GetSourceFieldsAsync(It.IsAny<IEnumerable<int>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<SourceFieldLabelDto>());

    repo.Setup(r => r.GetDocumentsAsync(It.IsAny<IEnumerable<ClaimedDoc>>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<DocumentRecord>
        {
            new(1, "US", docKey, "<bad xml>", null, false)
        });

    transformer.Setup(t => t.Transform(It.IsAny<DocumentRecord>(), It.IsAny<IReadOnlyList<RemapRuleDto>>(), It.IsAny<bool>(), It.IsAny<IReadOnlyDictionary<int, string>>()))
        .Throws(new Exception("boom"));

    var sut = CreateSut(repo, transformer, new RemapOptions());

    await sut.RunOneGlobalCycleAsync(CancellationToken.None);

    repo.Verify(r => r.ApplyBatchAsync(
        It.Is<IEnumerable<TransformedDoc>>(x => x.Any(d => d.Status == "ERROR")),
        It.IsAny<CancellationToken>()),
        Times.Once);
}
```

---

## 5Ô∏è‚É£ What you now have

‚úî Coverage of **business rules**
‚úî Confidence in **retry + error behavior**
‚úî Safe refactoring of orchestrator logic
‚úî Clear separation of unit vs integration tests

If you want next:

* Integration test for `SqlRemapRepository`
* Test helpers/builders to reduce noise
* Performance/parallelism assertions
* Naming conventions aligned to your team

Just say the word.
